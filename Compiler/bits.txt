printf "%s \n" lambda_to_string c; flush stdout;


let succ 	= Lambda ( "nfx", String "f(nfx)" )
let succ 	= Lambda ( 'n', Lambda ('s', Lambda('z', App( Char 's', App(Char 'n', App (Char 's', Char 'z'))))))
let add		= Lambda ( "mnfx", String "mf(nfx)" )
let add		= Lambda ( 'm', Lambda ('n', Lambda ('f', Lambda ('x', App(Char 'm', App(Char 'f', App(Char 'n', App(Char 'f', Char 'x'))))))))
let mult	= Lambda ( "mnfx", String "m(nf)x" )
let mult 	= Lambda ( 'm', Lambda ('n', Lambda ('f', Lambda('x', App(Char 'm', App(Char 'n', App(Char 'f', Char 'x')))))))


let rec beta_simplification expr = 
	match expr with
	| String e 		-> e
	| Lambda e 		-> e
	| App (e1, e2)	-> beta_simplification e1; beta_simplification e2


let rec lookup x (variables,values) = 
 	match variables, values with 
 	| y::yt, z::zt	-> if y = x then Some z else lookup x (yt,zt)
 	| [], [] 		-> None
 	| [], z::zt		-> None
 	| y::yt, []		-> 

 	match e1, e2 with
		| Lambda (id1, expr1), Lambda (id2, expr2) -> 
			let simplified_e2 = beta_simp e2 stack in 
			(match stack with
			| variables, values -> beta_simp e1 (id1::variables, simplified_e2::values))
		| Lambda (x,y), Char e 	-> beta_simp 
		| Char e, Char f 		-> beta_simp e stack; beta_simp f stack;
		| Char e, Lambda (x, y) -> beta_simp e stack; beta_simp (Lambda (x,y)) stack


		(beta_simp c ([],[]))

| Lambda (id1, exp1), App (exp2, exp3) 	->
			
				let simp_app = beta_simp e2 stack in
					beta_simp (App (e1, simp_app)) stack

					
		(match e1, e2 with
			| App (ex1, ex2), App (ex3, ex4) 	-> 
			| App (ex1, ex2), _ 				-> 
			| _ , App (ex1, ex2) 				-> 
			| _, _ 								-> 