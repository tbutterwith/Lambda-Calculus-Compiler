printf "%s \n" lambda_to_string c; flush stdout;


let succ 	= Lambda ( "nfx", String "f(nfx)" )
let add		= Lambda ( "mnfx", String "mf(nfx)" )
let mult	= Lambda ( "mnfx", String "m(nf)x" )


let rec beta_simplification expr = 
	match expr with
	| String e 		-> e
	| Lambda e 		-> e
	| App (e1, e2)	-> beta_simplification e1; beta_simplification e2


let rec lookup x (variables,values) = 
 	match variables, values with 
 	| y::yt, z::zt	-> if y = x then Some z else lookup x (yt,zt)
 	| [], [] 		-> None
 	| [], z::zt		-> None
 	| y::yt, []		-> 

 	match e1, e2 with
		| Lambda (id1, expr1), Lambda (id2, expr2) -> 
			let simplified_e2 = beta_simp e2 stack in 
			(match stack with
			| variables, values -> beta_simp e1 (id1::variables, simplified_e2::values))
		| Lambda (x,y), Char e 	-> beta_simp 
		| Char e, Char f 		-> beta_simp e stack; beta_simp f stack;
		| Char e, Lambda (x, y) -> beta_simp e stack; beta_simp (Lambda (x,y)) stack


		(beta_simp c ([],[]))


let rec beta_simp expr stack = 
	print_endline( "eval " ^ lambda_to_string expr);
	match expr with
	| Char e 			-> lookup e stack
	| Lambda (id, e1) 	-> Lambda (id, e1)
	| App (e1, e2) 		-> 
		match e1, e2 with
		| Char e, Char f	-> beta_simp e1 stack; beta_simp e2 stack
		| _ , _ 			->
		let simplified_e2 = beta_simp e2 stack in 
			let simplified_e1 = beta_simp e1 stack in
				print_endline ("simp e1 : " ^ lambda_to_string simplified_e1 ^ "  simp e2 : " ^ lambda_to_string simplified_e2);
				match simplified_e1 with
				| Lambda (id, expr1) 	->
					(match stack with
					| variables, values -> beta_simp expr1 (id::variables, simplified_e2::values))
				| Char x 				-> print_endline ("undefined variable " ^ Char.to_string x ^ " in " ^ Char.to_string x ^ lambda_to_string simplified_e2);
											Char x;